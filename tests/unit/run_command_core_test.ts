import { assertEquals, assertRejects, assertThrows } from "std/assert/mod.ts";
import { returnsNext, spy, SpyCall, Stub, stub } from "std/testing/mock.ts";

// Import the functions to test
import { formatFileSize, runCommand, validateNpub } from "../../src/commands/run.ts";
import * as resolverUtils from "../../src/lib/resolver-utils.ts";
import * as nostr from "../../src/lib/nostr.ts";
import { normalizeToPubkey } from "applesauce-core/helpers";

// Mock console and Deno.exit to prevent actual side effects
let consoleLogSpy: any;
let consoleErrorSpy: any;
let denoExitSpy: any;

function setupMocks() {
  consoleLogSpy = stub(console, "log", () => {});
  consoleErrorSpy = stub(console, "error", () => {});
  denoExitSpy = stub(Deno, "exit", () => {
    throw new Error("Deno.exit called");
  });
}

function teardownMocks() {
  consoleLogSpy?.restore();
  consoleErrorSpy?.restore();
  denoExitSpy?.restore();
}

function generateValidNpub(): string {
  return "npub105xzerq73d8456ea9c0s4xuv04h97j3m9swsa8u20dk96n3l9gdslddae9";
}

Deno.test("Run Command Core - Input Validation", async (t) => {
  await t.step("validateNpub should correctly validate npubs", () => {
    const validNpub = generateValidNpub();
    assertEquals(validateNpub(validNpub), true);

    assertEquals(validateNpub("invalid"), false);
    assertEquals(validateNpub(""), false);
    assertEquals(
      validateNpub("nsec1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq"),
      false,
    );
  });

  await t.step("formatFileSize should format various sizes correctly", () => {
    assertEquals(formatFileSize(0), "0 B");
    assertEquals(formatFileSize(1024), "1 KB");
    assertEquals(formatFileSize(1048576), "1 MB");
    assertEquals(formatFileSize(1073741824), "1 GB");
    assertEquals(formatFileSize(512), "512 B");
    assertEquals(formatFileSize(1536), "1.5 KB");
  });
});

// Skip server-dependent tests that cause hanging
// These tests attempt to start an actual HTTP server which blocks test completion
Deno.test.ignore("Run Command Core - Error Handling", async (t) => {
  let resolvePubkeyStub: any;
  let resolveRelaysStub: any;
  let listRemoteFilesStub: any;

  await t.step("should handle invalid npub parameter", async () => {
    setupMocks();

    try {
      await assertRejects(
        () => runCommand({}, "invalid_npub"),
        Error,
        "Deno.exit called",
      );

      // Verify that console.error was called for the invalid npub
      assertEquals(consoleErrorSpy.calls.length > 0, true);
    } finally {
      teardownMocks();
    }
  });

  await t.step("should handle no relays available", async () => {
    setupMocks();

    const validNpub = generateValidNpub();
    const options = {};

    // Mock resolveRelays to return empty array
    resolveRelaysStub = stub(resolverUtils, "resolveRelays", () => []);

    try {
      await assertRejects(
        () => runCommand(options, validNpub),
        Error,
        "Deno.exit called",
      );

      // Verify that console.error was called about no relays
      assertEquals(consoleErrorSpy.calls.length > 0, true);
    } finally {
      resolveRelaysStub?.restore();
      teardownMocks();
    }
  });

  await t.step("should handle relay connection errors", async () => {
    setupMocks();

    const validNpub = generateValidNpub();
    const pubkeyHex = normalizeToPubkey(validNpub);
    const options = {};

    // Mock dependencies
    resolveRelaysStub = stub(resolverUtils, "resolveRelays", () => ["wss://test.relay"]);
    listRemoteFilesStub = stub(nostr, "listRemoteFiles", () => {
      throw new Error("Failed to connect to relays");
    });

    try {
      await assertRejects(
        () => runCommand(options, validNpub),
        Error,
        "Deno.exit called",
      );

      // Verify error handling was triggered
      assertEquals(consoleErrorSpy.calls.length > 0, true);
    } finally {
      resolveRelaysStub?.restore();
      listRemoteFilesStub?.restore();
      teardownMocks();
    }
  });
});

// Skip server-dependent tests that cause hanging
Deno.test.ignore("Run Command Core - Successful Execution", async (t) => {
  let resolvePubkeyStub: any;
  let resolveRelaysStub: any;
  let listRemoteFilesStub: any;

  const mockFiles = [
    {
      path: "index.html",
      sha256: "a1b2c3d4e5f6789012345678901234567890123456789012345678901234567a",
      size: 1024,
      contentType: "text/html",
    },
    {
      path: "style.css",
      sha256: "b2c3d4e5f6789012345678901234567890123456789012345678901234567890",
      size: 2048,
      contentType: "text/css",
    },
  ];

  await t.step("should successfully execute with valid npub and files", async () => {
    setupMocks();

    const validNpub = generateValidNpub();
    const pubkeyHex = normalizeToPubkey(validNpub);
    const options = {};

    // Mock all dependencies for successful execution
    resolveRelaysStub = stub(resolverUtils, "resolveRelays", () => ["wss://test.relay"]);
    listRemoteFilesStub = stub(nostr, "listRemoteFiles", () => Promise.resolve(mockFiles));

    try {
      await runCommand(options, validNpub);

      // Verify successful execution logs
      assertEquals(consoleLogSpy.calls.length > 0, true);

      // Check that specific success messages were logged
      const logCalls = consoleLogSpy.calls.map((call) => call.args.join(" "));
      const hasResolverMessage = logCalls.some((log) => log.includes("resolver simulation"));
      const hasFilesMessage = logCalls.some((log) => log.includes("Found"));

      assertEquals(hasResolverMessage, true);
      assertEquals(hasFilesMessage, true);
    } finally {
      resolveRelaysStub?.restore();
      listRemoteFilesStub?.restore();
      teardownMocks();
    }
  });

  await t.step("should handle empty file list gracefully", async () => {
    setupMocks();

    const validNpub = generateValidNpub();
    const options = {};

    // Mock dependencies for empty file list
    resolveRelaysStub = stub(resolverUtils, "resolveRelays", () => ["wss://test.relay"]);
    listRemoteFilesStub = stub(nostr, "listRemoteFiles", () => Promise.resolve([]));

    try {
      await runCommand(options, validNpub);

      // Verify that "no files found" message was logged
      const logCalls = consoleLogSpy.calls.map((call) => call.args.join(" "));
      const hasNoFilesMessage = logCalls.some((log) => log.includes("No files found"));

      assertEquals(hasNoFilesMessage, true);
    } finally {
      resolveRelaysStub?.restore();
      listRemoteFilesStub?.restore();
      teardownMocks();
    }
  });
});

Deno.test("Run Command Core - Configuration Detection", async (t) => {
  let resolvePubkeyStub: any;
  let resolveRelaysStub: any;
  let listRemoteFilesStub: any;

  await t.step("should attempt to resolve pubkey from config when no npub provided", async () => {
    setupMocks();

    const testPubkey = normalizeToPubkey(generateValidNpub());
    const options = {};

    // Mock successful pubkey resolution from config
    resolvePubkeyStub = stub(resolverUtils, "resolvePubkey", () => Promise.resolve(testPubkey));
    resolveRelaysStub = stub(resolverUtils, "resolveRelays", () => ["wss://test.relay"]);
    listRemoteFilesStub = stub(nostr, "listRemoteFiles", () => Promise.resolve([]));

    try {
      await runCommand(options); // No npub parameter

      // Verify that resolvePubkey was called (config detection attempt)
      assertEquals(resolvePubkeyStub.calls.length, 1);

      // Verify that detection message was logged
      const logCalls = consoleLogSpy.calls.map((call) => call.args.join(" "));
      const hasDetectionMessage = logCalls.some((log) => log.includes("Detected npub"));

      assertEquals(hasDetectionMessage, true);
    } finally {
      resolvePubkeyStub?.restore();
      resolveRelaysStub?.restore();
      listRemoteFilesStub?.restore();
      teardownMocks();
    }
  });

  await t.step("should handle config resolution failure", async () => {
    setupMocks();

    const options = {};

    // Mock failed pubkey resolution from config
    resolvePubkeyStub = stub(resolverUtils, "resolvePubkey", () => {
      throw new Error("No public key available");
    });

    try {
      // This should trigger interactive mode or fail
      // Since we can't test interactive mode easily, it should fail
      await assertRejects(
        () => runCommand(options), // No npub parameter
        Error,
      );
    } finally {
      resolvePubkeyStub?.restore();
      teardownMocks();
    }
  });
});

Deno.test("Run Command Core - Output Formatting", async (t) => {
  let resolveRelaysStub: any;
  let listRemoteFilesStub: any;

  const mockFiles = [
    {
      path: "index.html",
      sha256: "a1b2c3d4e5f6789012345678901234567890123456789012345678901234567a",
      size: 1024,
      contentType: "text/html",
    },
    {
      path: "large-file.bin",
      sha256: "c3d4e5f6789012345678901234567890123456789012345678901234567890ab",
      size: 1048576, // 1MB
      contentType: "application/octet-stream",
    },
  ];

  await t.step("should format file information correctly", async () => {
    setupMocks();

    const validNpub = generateValidNpub();
    const options = {};

    resolveRelaysStub = stub(resolverUtils, "resolveRelays", () => ["wss://test.relay"]);
    listRemoteFilesStub = stub(nostr, "listRemoteFiles", () => Promise.resolve(mockFiles));

    try {
      await runCommand(options, validNpub);

      const logCalls = consoleLogSpy.calls.map((call) => call.args.join(" "));

      // Check that file information is properly formatted and displayed
      const hasFileCount = logCalls.some((log) => log.includes("Found 2 files"));
      const hasFileSize = logCalls.some((log) => log.includes("1 MB") || log.includes("1 KB"));
      const hasHashDisplay = logCalls.some((log) => log.includes("ðŸŒ¸"));

      assertEquals(hasFileCount, true);
      assertEquals(hasFileSize, true);
      assertEquals(hasHashDisplay, true);
    } finally {
      resolveRelaysStub?.restore();
      listRemoteFilesStub?.restore();
      teardownMocks();
    }
  });

  await t.step("should display resolver URL format correctly", async () => {
    setupMocks();

    const validNpub = generateValidNpub();
    const options = { port: 3000 };

    resolveRelaysStub = stub(resolverUtils, "resolveRelays", () => ["wss://test.relay"]);
    listRemoteFilesStub = stub(nostr, "listRemoteFiles", () => Promise.resolve([]));

    try {
      await runCommand(options, validNpub);

      const logCalls = consoleLogSpy.calls.map((call) => call.args.join(" "));

      // Check that resolver URL is displayed correctly
      const hasResolverUrl = logCalls.some((log) => log.includes(`${validNpub}.localhost:3000`));

      assertEquals(hasResolverUrl, true);
    } finally {
      resolveRelaysStub?.restore();
      listRemoteFilesStub?.restore();
      teardownMocks();
    }
  });
});
